```
Document number: P1017R0
Date: 20180428
Project: Programming Language C++, SG1
Authors:
    Hartmut Kaiser
    John Biddiscombe
Emails:
    hartmut.kaiser@gmail.com
    biddisco@cscs.ch
Reply to: hartmut.kaiser@gmail.com
```

# Executors should be variadic

This paper responds to the proposed resolution of an github issue 
[Executors:Issue9](https://github.com/executors/executors/issues/9)
posted 2 years ago relating to the currently proposed 
executor design paper [P0443](http://wg21.link/P0443).

## Introduction

The proposed executor interfaces (see P0443) are to be the fundamental bases 
for implementing parallelism for today's and - more importantly - any future 
application. Thus it is of utmost importance to come up with a design that is 
as flexible as possible and does not impose any limitations on possible future 
use use cases.

## Rationale

This paper attempts to provide a rationale for changing the current executor 
design (as outlined in P0443) such that all execution functions exposed by 
the executors should be variadic instead accepting nullary functions. The 
required specification changes are minimal and do not change any of the 
semantics proposed by P0443.

The following sections focus on various aspects and provides argumentation in 
favor of exposing variadic execution interfaces for all types of executors.


### Consistency with `std::async` and `std::thread`

In C++17 we have two API's related to scheduling tasks: `async` and `thread`.
The standard also defines `invoke` as a synchronous execution interface. All 
of those functions are specified to accept a variadic set of arguments. 

The C++ standard has to be as uniform and non-contradictory as possible. 
Therefor, the definition of interfaces pertaining to similar tasks should be 
as consistent as possible as well. Having all executors require for the user 
to pass in nullary function objects contradicts this fundamental requirement of
standardization.


### No reason not to be variadic (usability)

We posit that there is no strongly restricting reason for the executor interfaces
_not_ to be variadic. In our opinion, all argumentation we have seen from the 
authors of [P0443](http://wg21.link/P0443) in favor of nullary function interfaces
seems to be weak at best. This section attempts to list those arguments and 
provides a discussion from the standpoint of possible alternative design choices
that would allow for equivalent functionalities as proposed by 
[P0443](http://wg21.link/P0443), but without the limitation of requiring for the
function interface to be nullary. (for all quotes in this section, please see
[Executors:Issue9](https://github.com/executors/executors/issues/9))

<br>

> "Separate, variadic bulk analogues of async & invoke make sense to me, but I 
> think they are out of scope for this minimal proposal."

The proposed P0443 is everything but minimal at this point. The specification
of variadic execution interfaces would add a very small amount of additional
wording without any change in exposed semantics.

<br>

> "Moreover, I think it's important to reserve additional parameter slots ... 
> for parameters which carry semantics that executors will actually need to 
> customize."

Also:

> "Finally, I'm concerned variadic parameters would preclude an important 
> additional functionality that bulk executors will want to provide. We envision 
> that a future proposal will want to introduce the ability to create hierarchical 
> executors to support things like GPUs and executors that are composed of a 
> composition of other, more primitive executors."

These quotes refer to special arguments as proposed for the bulk
interfaces, namely factory functions for the generated results etc. We argue
that not only such very specific arguments (like the proposed factory functions)
are limiting the generality of the proposed APIs (as not all bulk executors
might have a need for factory functions or similar), they also unneededly leak
implementation details of a limited type of executors to the general users of
those interfaces.

Over-specifying the meaning of certain arguments to be passed to the 
executors inhibits the ability to express general use cases, especially for those 
we don't anticipate today.

The special arguments today - and any possible special argument that might
be required in the future - can alternatively easily passed to an underlying 
executor through a modular layered design of wrapping executors.

Here is a small example demonstrating this.
Let's assume, we have a two-way-executor (for simplicity we'll show only the
implementation of a blocking bulk execute implementation, the same
technique can be applied to all other executor APIs). We also assume that it exposes
functionality which is callable through a _variadic_ API:

```
struct two_way_executor
{
    template <typename F, typename ...Ts>
    void bulk_twoway_execute(F && f, size_t n, Ts &&... ts)
    {
        for (size_t i = 0; i != n; ++i)
        {
            invoke(f, i, ts...);
        }
    }
};
```

Now it is trivial to achieve the functionality that is relying on factory
functions for shared data by defining another executor that exposes functionality
similar to `bulk_twoway_execute` as specified by P0443 without any special
arguments, completely relying on a variadic bulk execution interface:


```
template <typename Executor, typename RF, typename SF>
struct shared_data_executor
{
    template <typename F, typename ...Ts>
    auto bulk_twoway_execute(F && f, size_t n, Ts &&... ts)
    {
        // implement as needed using the factory functions, while relying on
        // wrapped executor to do the work
        auto shared_results = rf(n);
        auto shared_data = sf();

        // PLEASE NOTE: from the standpoint of 'f' there is no discernible
        // difference to a direct implementation as mandated by P00443
        return exec.bulk_twoway_execute(forward<F>(f), n,
            std::ref(shared_results), std::ref(shared_data),
            forward<Ts>(ts)...);
    }

    Executor exec;
    RF rf;
    SF sf;
};
```

We invoke almost as before:

```
size_t shape = 100;
auto f = [](size_t, auto& shared_results, auto& shared_data) { ... };
auto result_factory = [](size_t n) {...};
auto shared_factory = []() {...};

auto shared_data_exec = 
    shared_data_executor{two_way_executor{}, result_factory, shared_factory};

shared_data_exec.bulk_twoway_execute(f, shape, ...);
```

We do not need even the currently proposed special arguments for the bulk
interfaces, more-so by applying the described implementation techniques we can 
clearly avoid adding more special arguments in the future. Thus the provided
argumentation that we cannot have variadics today because that would prohibit
adding other special arguments in the future is invalid.

<br>

Another rationale for non-variadic interfaces quoted from the mentioned document:

> "It's also not clear that there is any reason that an executor author would 
> want to customize how variadic parameters get forwarded."

We don't know of any use case for an executor to customize variadic parameter
forwarding either. We will however provide a valid and very important use case
for an executor having to be able to access (read) those parameters for performance
reasons. We will elaborate on this use case in
[this section](#section_argument_introspection).


### An executor can always package arguments into a nullary object if required

In general, a user shouldn't have to perform tasks like parameter forwarding that
can be applied mechanically and in a general purpose fashion.
In discussions the authors of P0443 have explained that the idea would be
to leave the mundane task of wrapping arguments into nullary function objects
to higher level control structures like (a future version of)
`std::async` or `std::invoke`, thus the executors wouldn't have to to that.

We however believe, that instead of relying on future convenience interfaces
to perform the task of packaging arguments, executors can always perform this
task themselves if an underlying execution context requires this. Not all
executors may even have to perform that task to begin with.

The discussed executor interfaces are fundamental to today's and all future
parallelism library features and many users (and not only library writers) will
use those directly in order to implement their own functionalities. These users
would have to repeatedly write code packaging the arguments of their functions
into nullary objects.

From the standpoint of library developers, the enforcement of nullary function
interfaces will cause unnecessary implementation complexity on things like the
parallel algorithms. Why sprinkle parameter packing/unpacking over all the
place where executors are (directly) used?

Making the executor interfaces nullary requires the use of a lambda which is error
prone (arguments must be forwarded into the capture, must be moved/forwarded
out of the capture when calling the function, and the lambda would have to be
mutable), for instance:

```
template <typename F, typename ... Args>
future<result_of_t<F&&(Args&&...)>> foo(F && f, Args && ... args)
{
    return my_exec.twoway_execute(
        [f = forward<F>(f), ...args = forward<Args>(args)]() mutable
        {
             return invoke(forward<F>(f), forward<Args>(args)...);
        });
}
```

Alternatively we would have to introduce a lightweight `bind` helper that moves
its arguments, e.g. something like:


```
template <typename F, typename ... Args>
future<result_of_t<F&&(Args&&...)>> foo(F && f, Args && ... args)
{
    return my_exec.twoway_execute(
        deferred_call(forward<F>(f), forward<Args>(args)...)
    );
}
```

All of this increases implementation complexity.

At the same time, with a variadic interface the same function implementation
would just look like:

```
template <typename F, typename ... Args>
future<result_of_t<F&&(Args&&...)>> foo(F && f, Args && ... args)
{
    return my_exec.twoway_execute(forward<F>(f), forward<Args>(args)...);
}
```

From all of this we propose that making the interfaces variadic adds a small
amount of specification complexity, but massively reduces implementation
complexity of all code that uses executors. The executors themselves would
not necessarily become more complex (`twoway_execute` in the simplest 
blocking case would call `invoke` and could use `thread` if non-bloking,
both of which are already variadic).



### <a name="section_argument_introspection"></a> Executors can't see original arguments (possible performance problem)

TBD

### Existing implementation experience

- HPX

